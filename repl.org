#+TITLE: REPL-driven development

#+begin_quote
  With Lisp-based languages, the “unit of compilation” is a single, top-level form. Once the REPL has read in a single, well-formed “expression”, it can immediately compile it and then run it. The overall compilation and execution model for Clojure (and ClojureScript – with some caveats) is identical between the REPL and the “normal” command-line execution approach: read a form, compile it, execute it (and, in the REPL, print the result).

  With nearly all other languages, they are typically designed so the “unit of compilation” is a file (or module) and then if they have an interactive console for the language, it’s often a separate interpreter allowing for line-by-line (or statement-by-statement) reading and evaluation.

  For some languages, the interactive console reuses some of the same machinery that “normal” compilation/execution uses (for primarily interpreted languages). For compiled languages, the interactive console is a separate thing that often has some semantic differences and some limitations.
#+end_quote
By [[https://clojureverse.org/t/why-other-languages-dont-have-repls-like-lisps/8640/2][@seancorfield]].

#+begin_quote
  I mentioned inspecting code already, but let me give an example here as well, you really want the REPL to auto-complete and show you the doc for various functions and global vars, that’s basic introspection, but it means the runtime must have first class doc-string and keep them around along the functions and the global vars, which again, isn’t something all languages do, like in Java, you need access to source files and you have to parse them to get the comment block above the corresponding methods to retrieve their doc, so it’s missing basic REPL introspection. Without that, again, a REPL is much less useful.
#+end_quote
By [[https://clojureverse.org/t/why-other-languages-dont-have-repls-like-lisps/8640/8][@didibus]].

#+begin_quote
  A REPL is, by nature, a very sequential process: it reads, then evals, then prints, and then starts over. One REPL = One thread. Concurrency is achieved by having several REPLs.
#+end_quote

#+begin_quote
  Even the simplest REPL still has the full power of Clojure in it! We can start with something very basic, like server.repl, send our own server’s code to it first thing after connecting, and then take control over stdin/stdout and start serving our own protocol with our own execution model.

  This is called “upgrading” your REPL and that’s how Christophe Grand’s Unrepl works, for example. The beauty of it is zero dependencies: you only need Clojure and nothing more. Everything you need you bring with you.
#+end_quote
From [[https://tonsky.me/blog/clojure-sublimed-3/][Clojure Sublimed 3]], ~REPL, upgraded~ section.

* Objectives
- Come up with a model for REPL-driven development that:
  - Provides ~(break)~ that starts a new sub-REPL in given point and gives access to the local context.
  - Starts a new sub-REPL automatically when an error is encountered and behaves like ~(break)~ does, but additionally giving access to the error object.
  - Sub-REPLs nests and each level can be quit using ~:repl/quit~.
  - Is based on the socket REPL, simplicity and extensibility rather than behind-the-scene magic.
  - Gets out of the way: my screen is small and all I want to look at is my code. ~C-x C-e~ displays results inline like Cider does. Only when needed (such as when an error is thrown), the REPL is brought forwards (probably a split view code/REPL is best).
  - Works in unsaved buffers. This is really important, as I work in Org mode files in "zoomed-in" mode (~C-c '~ when in a source block opens it in a new buffer which doesn't get saved until we zoom out of it, at which point its contents update the original source block). Having to zoom out and save constantly is a big pain and should only happen once I'm happy with the code block as such.
  - Is a suitable setup for production processes and not only development.
  - Allows hot-code patching in production if absolutely necessary.

* Proof-of-concept

** Deps
#+begin_src clojure :tangle deps.edn
  {:paths ["src"]
   :aliases
   {:repl-server
    {:exec-fn jakub-stastny.dev.repl.server/start-server
     :exec-args {:name "repl-server"
                 :port 5555
                 :accept jakub-stastny.dev.server.repl/repl
                 :server-daemon false}}}}
#+end_src

- *Ref:* [[https://clojure.org/guides/deps_and_cli#socket_repl][Deps and CLI guide: socket REPL]].
- [[https://github.com/clojure/clojure/blob/38524061dcb14c598c239be87184b3378ffc5bac/src/clj/clojure/main.clj#L368][clojure.main/repl]].

** ~(break)~
https://github.com/matthiasn/talk-transcripts/blob/master/Halloway_Stuart/REPLDrivenDevelopment.md

#+begin_src clojure
(defmacro break []
  `(clojure.main/repl
    :prompt #(print "debug=> ")
    :read readr
    :eval (partial contextual-eval (local-context))))

(defn foo []
  (let [a 1] (break) a))

(foo)
#+end_src

** REPL server
#+begin_src clojure :tangle src/jakub-stastny/dev/repl/server.clj :mkdirp yes
  (ns jakub-stastny.dev.repl.server
    (:require [clojure.core.server :as s]
              [jakub-stastny.dev.repl :as pg]))

  (defn repl []
    (clojure.main/repl
     :caught pg/handle-error
     :prompt #(print (str "host.socket.repl." (ns-name *ns*) "=> "))
     :print prn ; TODO pretty-print
     :init s/repl-init
     :read s/repl-read))

  (defn start-server [{:keys [port] :as opts}]
    (println (str "~ Starting socket REPL on port " port "."))
    (println (str "  Connect: rlwrap nc localhost " port))
    ; We have to print the prompt or inf-clojure won't recognise the REPL server being ready.
    (future (s/start-server opts))
    ;(repl)
    )
#+end_src

#+begin_src clojure :tangle src/jakub-stastny/dev/repl.clj :mkdirp yes
  (ns jakub-stastny.dev.repl
    (:require
     [clojure.string :as str]
     [clojure.core.server :as rs]))

  (def nesting-level (atom 0))

  (defn error-prompt [e]
    #(print (str
             (last (str/split (str (type e)) #"\.")) "."
             ,*ns* "."
             @nesting-level
             "=> ")))

  ;; repl-read respects :repl/quit
  (declare handle-error)
  (defn start-nested-repl [e]
    (println "Inspect e for details about the error.")
    (clojure.main/repl :init #(def e e) :prompt (error-prompt e) :caught handle-error :read rs/repl-read))

  (defn handle-error [e]
    (swap! nesting-level inc)
    (println (ex-message e) (or (ex-data e) ""))
    (start-nested-repl e)
    (swap! nesting-level dec))

  (comment
    (conj {} 1)
    (ex-data e)
    (ex-message e)
    (throw (ex-info "Fuck this" {:cant-be-bothered true}))
    :repl/quit
    ,)
#+end_src

** Usage
#+begin_src sh
  clojure -X:repl-server
  clojure -X:repl-server :port 1234
#+end_src

** Playground
#+begin_src clojure :tangle src/playground.clj :mkdirp yes
  (ns playground (:require [playground.repl :as pr]))

  (comment
    ;(pr/repl)

    ; Get out of nested REPLs with exception context.
    :repl/quit

    (conj {} 1)
    (throw (ex-info "Fuck this" {:cant-be-bothered true}))

    ; This is the starting point for our playground.
    (filter odd?)
    (range 10)
    ,)
#+end_src

** Emacs integration
*** Take I: ~inf-clojure~
#+begin_src emacs-lisp :tangle .dir-locals.el
  ((nil
    (inf-clojure-custom-startup . "clojure -X:repl-server :port %d")
    ;(inf-clojure-custom-startup . ("localhost" . 5555))
    (inf-clojure-custom-repl-type . clojure)))
#+end_src

- Doc [[https://github.com/clojure-emacs/inf-clojure#startup][inf-clojure#startup]].
- Source [[https://github.com/clojure-emacs/inf-clojure/blob/master/inf-clojure.el][inf-clojure.el]].

**** TODO How to load a whole buffer?
/Reloading a namespace (via require :reload/require :reload-all)/

**** ISSUE
- Wouldn't work in Org narrowed source window.

**** WORKAROUND
- Open [[./src/playground.clj]].
- Start the REPL using ~inf-clojure-socket-repl~.
- Close the file.
- Go back to the Org file and work as normal.

**** Outcome
- Inf-clojure doesn't behave the way I want, in particular it forces me to work in split view at all times.
- Additionally things were broken and took time to debug.

*** Discussion: why is there no Emacs pREPL?
It seems like the way to go, why isn't there a plugin?

Scenario: the main process has 2 REPLs running, a socket REPL and another pREPL for Cider-like thingy.

ACTUALLY: then I'd loose my nested REPL interface, I wouldn't even know what's been happening.

OR NOT? Like it'd work under the hood, but how would it behave?

It could report exceptions same way Cider does C-x C-e at which point you open side-by-side and debug.

Of course it'd have to pretty-print it, not show the "real" {:tag ...} communication.

You could tweak what inf-clojure sends and that'd do. It'd still show the whole {:tag ...} thingy on receive, but whatevs.

*** Take II: custom Emacs plugin
**** Resources
- Emacs EDN parser [[https://github.com/clojure-emacs/parseedn][parseedn]].
- https://tonsky.me/blog/clojure-sublimed-3/
- [[https://github.com/Olical/propel][propel]].
- [[https://oli.me.uk/clojure-socket-prepl-cookbook/][Clojure socket pREPL cookbook]].
- [[https://blog.jakubholy.net/how-to-use-clojure-1.10-prepl/][How to use Clojure pREPL]].

**** Architecture
- Start a normal socket REPL, upgrade to pREPL at the beginning of the client session.
