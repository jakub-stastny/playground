#+TITLE: REPL-driven development

#+begin_quote
  With Lisp-based languages, the “unit of compilation” is a single, top-level form. Once the REPL has read in a single, well-formed “expression”, it can immediately compile it and then run it. The overall compilation and execution model for Clojure (and ClojureScript – with some caveats) is identical between the REPL and the “normal” command-line execution approach: read a form, compile it, execute it (and, in the REPL, print the result).

  With nearly all other languages, they are typically designed so the “unit of compilation” is a file (or module) and then if they have an interactive console for the language, it’s often a separate interpreter allowing for line-by-line (or statement-by-statement) reading and evaluation.

  For some languages, the interactive console reuses some of the same machinery that “normal” compilation/execution uses (for primarily interpreted languages). For compiled languages, the interactive console is a separate thing that often has some semantic differences and some limitations.
#+end_quote
By [[https://clojureverse.org/t/why-other-languages-dont-have-repls-like-lisps/8640/2][@seancorfield]].

#+begin_quote
  I mentioned inspecting code already, but let me give an example here as well, you really want the REPL to auto-complete and show you the doc for various functions and global vars, that’s basic introspection, but it means the runtime must have first class doc-string and keep them around along the functions and the global vars, which again, isn’t something all languages do, like in Java, you need access to source files and you have to parse them to get the comment block above the corresponding methods to retrieve their doc, so it’s missing basic REPL introspection. Without that, again, a REPL is much less useful.
#+end_quote
By [[https://clojureverse.org/t/why-other-languages-dont-have-repls-like-lisps/8640/8][@didibus]].

#+begin_quote
  A REPL is, by nature, a very sequential process: it reads, then evals, then prints, and then starts over. One REPL = One thread. Concurrency is achieved by having several REPLs.
#+end_quote

#+begin_quote
  Even the simplest REPL still has the full power of Clojure in it! We can start with something very basic, like server.repl, send our own server’s code to it first thing after connecting, and then take control over stdin/stdout and start serving our own protocol with our own execution model.

  This is called “upgrading” your REPL and that’s how Christophe Grand’s Unrepl works, for example. The beauty of it is zero dependencies: you only need Clojure and nothing more. Everything you need you bring with you.
#+end_quote
From [[https://tonsky.me/blog/clojure-sublimed-3/][Clojure Sublimed 3]], ~REPL, upgraded~ section.

* Resources
- Stuart Halloway: [[https://github.com/matthiasn/talk-transcripts/blob/master/Halloway_Stuart/REPLDrivenDevelopment.md][REPL-driven development]] (transcript).
- LambdaIsland: [[https://lambdaisland.com/guides/clojure-repls/clojure-repls][Clojure REPLs]].
- [[https://nextjournal.com/mk/rich-hickey-on-repls][Rich Hickey on REPLs]].
- YouTube: [[https://www.youtube.com/watch?v=SrKj4hYic5A&embeds_euri=https%3A%2F%2Fnextjournal.com%2F&feature=emb_imp_woyt][Programming should eat itself]].

* Notes
- REPL already gives you ~*e~ for errors.

#+begin_comment
REPL Sean

In a prod server, connect over SSH & inspect shit, occasionally patch the live process.
REVEAL, cognitec rebel, portal
add-lib
tap> listen on queue

@hiredman (coworker) uses minor-clj mode and socket repl

https://clojure.github.io/clojure/clojure.inspector-api.html

REPL CLJS

https://www.youtube.com/watch?v=BZNJi5pP8fU&t=45s&ab_channel=MikeZamansky -> boils down to https://github.com/zamansky/shadow-cljs-demo/blob/master/src/main.cljs

https://docs.cider.mx/cider-nrepl/usage.html
https://docs.cider.mx/cider/index.html
https://docs.cider.mx/cider/cljs/shadow-cljs.html
https://shadow-cljs.github.io/docs/UsersGuide.html#cider

I find myself repeating a lot of manual steps at the REPL for running my development environment.
Consider creating a 'dev' namespace in your project (e.g myproject.dev) in which you define functions for automating common development tasks (for example: starting a local web server, running a database query, turning on/off email sending, etc.)
(doto "test" prn)
https://clojure.github.io/clojure/clojure.reflect-api.html#clojure.reflect/reflect

To achieve this goal, I make the application itself into a transient object. Instead of the application being a singleton tied to a JVM process, I write code to construct instances of my application, possibly many of them within one JVM. Each time I make a change, I discard the old instance and construct a new one. The technique is similar to dealing with virtual machines in a cloud environment: rather than try to transition a VM from an old state to a new state, we simply discard the old one and spin up a new one.
Designing applications this way requires discipline. First and foremost, all state must be local. Any global state, anywhere, breaks the whole model. Second, all resources acquired by the application instance must be carefully managed so that they can be released when the instance is destroyed.
https://cognitect.com/blog/2013/06/04/clojure-workflow-reloaded
https://eli.thegreenplace.net/2017/notes-on-debugging-clojure-code/
https://github.com/walmartlabs/system-viz
https://docs.datomic.com/cloud/other-tools/REBL.html
https://github.com/metasoarous/oz
https://vlaaad.github.io/reveal/

https://clojureverse.org/t/using-the-repl-with-reagent/3970/5

It looks that the only cider can provide a good enough completion experience at the moment. I'd like to switch to inf-clojure + eglot.

I’m interested in this sort of setup as well. I would hope eglot would provide the completions in that scenario. Maybe through corfu if desired
#+end_comment

if there is a file named user.clj at the root of the Java classpath, Clojure will load that file automatically when it starts.

*** TODO Code reloading
- Consider https://github.com/clojure/tools.namespace
- https://cognitect.com/blog/2013/06/04/clojure-workflow-reloaded
